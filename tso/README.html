<!DOCTYPE html>
<html><body>
<head>
<style>
p  { margin-top: 0.5em; margin-bottom: 0.0em; }
ul { margin-top: 0.0em; margin-bottom: 0.5em; }
li { margin-top: 0.0em; margin-bottom: 0.0em; }
blockquote {
  border: 1px solid #999;  border-radius: 0.1em;
  padding: 5px;            background-color: mintcream;
}
code {
  background-color: whitesmoke;
  border: 1px solid #999;  border-radius: 0.3em;
  font-family: Monaco, monospace;
  padding: 0px;
  white-space: pre
}
.block {
  margin-top: 0.5em;
  background-color: snow;  display: block;
  padding: 5px;
}
table, th, td {
    vertical-align: top;
    text-align: left;
    border-collapse: collapse;
    border: 1px solid grey;
    margin: 0.5em 0.5em;
    padding: 12px 15px;
}
table { min-width: 400px;         }
th    { background-color: LightCyan; }
td    { background-color: azure; }
</style>
</head>
<h1>TSO: tab separated objects</h1>
<p>
<blockquote> <b>WARNING:</b> TSO is currently incomplete.
<p>
A serializer is implemented. Deserializer coming soon.
</blockquote>
<p>
TSO is a concise and expressive data serialization format. If JSON and CSV had
a baby then their prodigal child would be something like TSO.
<p>
Unlike CSV, TSO supports nested records and has an actual spec. Unlike JSON,
TSO is concise and large lists of records (one of the most common kinds of data
that needs to be serialized) can be made very readable.
<p>
Features: <ul>
<li>Serialize nested arbitrary data
</li>
<li>Human readable and writeable. Favors readability over writeability.
</li>
<li>Supported types: none, boolean, number, string, table (list/map hybrid)
</li>
<li>Design supports (future) fast serialization and deserialization implementation
</li>
</ul>
<p>
<blockquote> Did you know that CSV is both faster to parse and almost as compressed as
protobufs? <a href="https://blog.mbedded.ninja/programming/serialization-formats/a-comparison-of-serialization-formats/">I was surprised too</a>.</blockquote>
<p>

<p>

<h2><a id="Starting_Example" href="#Starting_Example">☍</a>Starting Example</h2>

<p>
TSO represents the items in a table as a series of tab separated values.
Similar to CSV, newlines start a new table. The first character specifies
the type, <code>.keys</code> are strings.
<p>
<code class="block">-- JSON: [
--   [1, 2, 3],
--   {"name": "John", "birthday": "1999-10-31"}
-- ]

-- TSO:
1	2	3
.name	"John	.birthday	"1999-10-31
</code>
<p>
<code>#</code> specifies a header which extracts specific keys as indexes in the
tab-separated column.
<p>
<code class="block">-- JSON: [
--   {"id": 1, "name": "John",   "birthday": "1999-10-31"},
--   {"id": 2, "name": "Maxine", "birthday": "1998-12-25"}
-- ]

-- TSO
#"id	"name	"birthday
1	"John	1999-10-31
2	"Maxine	1998-12-25
</code>
<p>
Unlike CSV, TSO supports nested data:
<p>
<code class="block">-- JSON: [
--   users = [
--     {"id": 1, "name": "John",   "birthday": "1999-10-31"},
--     {"id", 2, "name": "Maxine", "birthday": "1998-12-25"}
--   ],
--   accounts = [
--     {"userId": 1, "ammount": 1000, "kind": "savings"},
--     {"userId": 1, "ammount": 100,  "kind": "checking"},
--     {"userId": 2, "ammount": 120,  "kind": "checking", "notes": [
--       "2020-01-03: wants investment advice", "2019-11-05: yelled at clerk"
--     ],
--   ],
-- ]

-- TSO
.users	{
 #"name	"birthday
 John	1999-10-31
 Maxine	1998-12-25
}

.accounts	{
 #"userId	"ammount	"kind
 1	1000	"savings
 1	100	"checking
 2	120	"checking	.notes	{
  "2020-01-03: wants investment advice	"2019-11-05: yelled at clerk
 }
}
</code>
<p>
Other quality of life features will be added as well
<code class="block">-- line comments
"""
Add a "description" as metadata
"""
@name	"my.data.name	-- set the doc name
@ibase	10	-- change the integer base (10 is default)
</code>
<p>
<h2><a id="Types" href="#Types">☍</a>Types</h2>
The type of an item is determined by the first character after the tab.
Whitespace is ignored. All values except tables end with a tab <code>\t</code> character.
Tables end with a newline (though they can be continued on the next line with
the <code>+</code> character).
<p>
<table>
<tr>
<th>character</th>
<th>description
</th>
</tr>
<tr>
<td><code>n</code></td>
<td>none.
<p>
lua <code>ds.none</code>, python <code>None</code>, C/java/etc <code>null</code>
<p>
</td>
</tr>
<tr>
<td><code>t</code> <code>f</code></td>
<td>boolean true and false
</td>
</tr>
<tr>
<td><code>$</code> or <code>0-9 a-f A-F</code></td>
<td>integer parsed using (base = attr <code>ibase</code>)
</td>
</tr>
<tr>
<td><code>^</code></td>
<td>floating point parsed using (base = attr <code>fbase</code>)
</td>
</tr>
<tr>
<td><code>"</code></td>
<td>string (binary data)
<p>
Examples
<code class="block">-- 3, "a string", 42
3, "a string	42	

"a multiline string\t &lt;-- that's a tab.
'This is on the next line. The next line is empty:
'	3 -- after the string there is a 3 integer
</code>
<p>
A tab <code>\t</code> or newline <code>\n</code> end the string. To continue the string
after a newline use a <code>'</code> as the first non-whitespace character
following the newline.
<p>
To encode a tab use <code>"\t"</code>. To encode a <code>\</code> character use <code>"\\"</code> or
simply use <code>'\'</code> followed by
neither <code>'\'</code> or <code>'t'</code>.
<p>
<p>
</td>
</tr>
<tr>
<td><code>{</code></td>
<td>nested table until <code>}</code>
</td>
</tr>
<tr>
<td><code>.</code></td>
<td>key, the following item is a value
<p>
Only string (binary) keys are supported. If you need other kinds of
keys then encode whatever type you want in the string
<p>
</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>row (nested table) delimiter
<p>
Conceptually this ends the current row (non bracketed <code>{}</code> table) and
starts a new row
</td>
</tr>
</table>
<p>
<b>A note on Tables</b>
<p>
Tables can contain both indexed values (like a traditional list) as well
as string-keyed values (like a map). This is more similar to a
serialization format like XML which contain both attributes and data.
<p>
<blockquote> <b>Recommendation:</b> this is the native behavior of Lua tables. In
python or javascript you would want to key off the list vs index
depending on the type of the key. In compiled languages, just offer
different <code>get</code> methods.
</blockquote>
</body></html>
