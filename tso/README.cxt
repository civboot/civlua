[{h1}TSO: tab separated objects]

[" [*WARNING:] TSO is currently incomplete.

   A serializer is implemented. Deserializer coming soon.
]

TSO is a concise and expressive data serialization format. If JSON and CSV had
a baby then their prodigal child would be something like TSO.

Unlike CSV, TSO supports nested records and has an actual spec. Unlike JSON,
TSO is concise and large lists of records (one of the most common kinds of data
that needs to be serialized) can be made very readable.

Features: [+
* Serialize nested arbitrary data
* Human readable and writeable. Favors readability over writeability.
* Supported types: none, boolean, number, string, table (list/map hybrid)
* Named headers support something like type tagging.
* Design supports (future) fast serialization and deserialization implementation
]

[" Did you know that CSV is both faster to parse and almost as compressed as
   protobufs? [<@compare>I was surprised too].]

[{!:href=https://blog.mbedded.ninja/programming/serialization-formats/a-comparison-of-serialization-formats/}compare]

[!--------------------------------]
[{:h2}Starting Example]
[! Recommendation for text editors: increase your tab size
vim	:set ts=12
]

TSO represents the items in a table as a series of tab separated values.
Similar to CSV, newlines start a new table. The first character specifies
the type, [$.keys] are strings.

[##
-- JSON: [
--   [1, 2, 3],
--   {"name": "John", "birthday": "1999-10-31"}
-- ]

-- TSO:
1	2	3
.name	"John	.birthday	"1999-10-31
]##

[$#] specifies a header which extracts specific keys as indexes in the
tab-separated column.

[##
-- JSON: [
--   {"id": 1, "name": "John",   "birthday": "1999-10-31"},
--   {"id": 2, "name": "Maxine", "birthday": "1998-12-25"}
-- ]

-- TSO
#"id	"name	"birthday
1	"John	1999-10-31
2	"Maxine	1998-12-25
]##

Unlike CSV, TSO supports nested data with named headers:

[##
-- JSON: [
--   users = [
--     {"id": 1, "name": "John",   "birthday": "1999-10-31"},
--     {"id", 2, "name": "Maxine", "birthday": "1998-12-25"}
--   ],
--   accounts = [
--     {"userId": 1, "ammount": 1000, "kind": "savings"},
--     {"userId": 1, "ammount": 100,  "kind": "checking"},
--     {"userId": 2, "ammount": 120,  "kind": "checking", "notes": [
--       "2020-01-03: wants investment advice", "2019-11-05: yelled at clerk"
--     ],
--   ],
-- ]

-- note: headers are specified first, then cleared, then used by name
:user	"name	"birthday
:account	"userId	"ammount	"kind

.users	{#user
 John	1999-10-31
 Maxine	1998-12-25
}

.accounts	{#account
 1	1000	"savings
 1	100	"checking
 2	120	"checking	.notes	{
  "2020-01-03: wants investment advice	"2019-11-05: yelled at clerk
 }
}
]##

Other quality of life features:
[##
-- line comment, can appear at start of line or after any tab
-- @ defines global attributes. Some of them (ibase, fbase) affect
-- parsing. All attributes can be read by the deserializer
@name	"my.data.name	-- set the doc name
@doc
+"This is a multiline string
 'documenting the purpose of this data
 'and how it should be used
@ibase	10	-- change the integer base (10 is default)
]##

[{:h2}Types]
The type of an item is determined by the first non-whitespace character after
the newline or tab. All values except tables end with a tab [$\t] character,
the behavior of tables is documented below.

[{table}
+ character | description
+ [$n] | none.

  lua [$ds.none], python [$None], C/java/etc [$null]

+ [$t] [$f] | boolean true and false
+ [$$] or [$0-9] | integer parsed using (base = attr [$ibase])
+ [$^] | floating point parsed using (base = attr [$fbase])
+ [$"] | string (binary data)

  Examples
  [##
  -- 3, "a string", 42
  3, "a string	42	
  
  "a multiline string\t <-- that's a tab.
  'This is on the next line. The next line is empty:
  '	3 -- after the string there is a 3 integer
  ]##

  A tab [$\t] or newline [$\n] end the string. To continue the string
  after a newline use a [$'] as the first non-whitespace character
  following the newline.

  To encode a tab use [$"\t"]. To encode a [$\] character use [$"\\"] or
  simply use [$'\'] followed by
  neither [$'\'] or [$'t'].


+ [${] | nested table until [$}].
+ [$.] | key, the following item is a value

  Only string (binary) keys are supported. If you need other kinds of
  keys then encode whatever type you want in the string

+ [$\n] | row (inner table) delimiter

  Conceptually this ends the current row (non bracketed [${}] table) and
  starts a new row

+ [$+] | row continuation

  This continues the previous row and is commonly used for multiple key/values
  [##
  .key1	"value1
  +.key2	"value2
  ]##

+ [$*] | bracket table continutation (very rare)

  This is necessary to represent a table of the form [$rows={{1,2},{3,4}, 5, 6}]
  (note that 5 and 6 are NOT part of a row)
  [##
  .rows	{
    1	2	-- row 1
    3	4	-- row 2
    *5	6	-- note: NOT a row, individual values
  }
  ]##

  It is available mostly so that arbitrary data can be represented.

+ [$:] | field specification

  This specifies the "fields" for a single table. It can also be used at the root
  level to create a named field specification.

  [##
  JSON: [0, {"field1": 1, "field2": 2}, 3]
  TSO:
  :ty1	"field1	"field2
  0	{:ty1
    1	2
  }	3
  ]##

  This is kind of like "type tagging" and is useful when you have lots of data
  with lots of embedded types.

+ [$#] | field header specification

  This specifies the fields for the list of tables. See the "users" and "accounts"
  example for how it is used.
]

[*A note on Tables]

Tables can contain both indexed values (like a traditional list) as well
as string-keyed values (like a map). This is more similar to a
serialization format like XML which contain both attributes and data.

[" [*Recommendation:] this is the native behavior of Lua tables. In
   python or javascript you would want to key off the list vs index
   depending on the type of the key. In compiled languages, just offer
   different [$get] methods.
]

[{:h2}Special Keys]

The following are reserved keys for the table. Serializing a table with these
keys will result in the specified behavior. Deserializing that table will
result in the specified field being set.

[{table}
+ [$__field]    | field specification table.

  This means that the first N indexes use the keys specified.

+ [$__fieldh] | specifies the field specification for the "rows" (table items
  in the list)
]
