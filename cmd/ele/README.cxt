[{h1}Ele: Extendable Lua Editor]

Ele is an (**In Development**) [*E]xtendable [*L]ua [*E]ditor.

Ele's primary goals are: [+
* Implemented in a minimal amount of understandable code. It is the main editor
  for [@Civboot]
* Enjoyable and extendable for developers to fit their workflow [+
  * undo/redo, syntax highlighting, plugins, user-configurable bindings
    (supports vim/emacs style), etc.
]
* Implements a lua shell (zsh competitor)
* Can handle any size text file
* Cross platform (currently vt100-only protocol, which should run anywhere)
]

Non-goals of Ele are: [+
* Focusing on performance against the other goals. It should be fast enough
  to be an editor and should not choke on large files -- otherwise performance
  is not important.
]

[{h1}Architecture]

Ele is architected using the MVI (model-view-intent) architecture, also
known as the "React architecture" from the web library of the same
name.

[$$
   ,_____________________________________________
   | intent(): keyboard, timer, executor, etc    |
   `~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
   /\                                    || Data + events
   || Data + scheduled                   \/
  ,__________________   Data + scheduled ,____________________________
  | view(): paint    | <================ | model(): keybind, actions  |
  `~~~~~~~~~~~~~~~~~~'                   `~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
]$

In practice, this is accomplished in four coroutines spawned
by [/ele.lua]'s [$main] function: [+
* A coroutine that listens to stdin for vt100 key sequences
  and sends event (plain-old-table values) to the [$keys]
  channel.
* A coroutine that listens to key actions and converts them
  to events (again, plain-old-tables) based on the [@ele.bindings],
  which are sent on an events channel. This also handles
  chords correctly, see the [@ele.bindings] documentation.
* A coroutine that listens for event tables, looks up their
  [$action] in [@ele.actions] and runs the appropriate action.
* A coroutine that "draws" the current display once per "frame"
  This is done by recursing the tree from [$Editor.root] down,
  having them write the relevant text to a [@vt100.Term] object,
  which gets flushed to the display at the end.
]

This roughly implements the MVI architecture because ALL actions
are performed sequentially based on the ordering in the [$events]
channel.

Actions or plugins have the option to spawn their own coroutine. However,
this behavior should be extremely rare, and reserved mostly for things that
really can happen concurrently with no user feedback needed, such as saving a
file, finding file lints, or updating syntax highlighting. Most real-world
editor operations can block the user while they happen, and if they can't
then they should consider not being included as an editor operation. Some
exceptions such as searching for patterns in a recursive tree should be
spawned as a coroutine but be cancelled if the user modifies the buffer
that the results are being written to in any way.

[{h1}Adding Bindings]
Adding simple bindings is easy. Simply insert the space-separated chord
of keys you want to go to your binding to one of ele's default modes, or
create your own.  [@ele.bindings]'s [$command], [$insert] and/or [$system]
entries are where you will find the default modes. For instance,
the following will insert the expected text at the cursor position
from command mode:

[{$$ lang=lua}
local B = require'ele.bindings'
B.command['y y'] = {action='insert', 'Why oh why did I bind this?\n'},
]$

To write your own action you must: [+
* Add a callable to [@ele.actions] which implements the intended behavior. The
  signature is: [$fn(Editor, event, Channel[event])]. You may modify the Editor
  in the appropriate way for your action.  You are recommended to handle
  [$event.times] to do your action multiple times (if that makes sense for your
  action). Note that you are free to throw errors -- any errors will be caught
  and logged.

* Add a binding to an editor mode. The binding can either be a plain table,
  which is the event that will be generated, or a [$fn(KeySt) -> ev?] callable.
  Using the callable API is slightly complex but allows for complex key
  interactions where you build-up a command with a chaing (aka "chord") of
  multiple key inputs. Refer to the [@ele.bindings] documentation.
]

[{h1}Editor API]
[@ele.Editor] is the main object most custom actions or Ele scripts will
interact with. It has several fields, but the fields and methods that most
folks will care about are: [+
* [$edit]: this is the current edit buffer and is typically where the
  user wants to insert or otherwise interact with text. It is
  typically a [@ele.edit.Edit] instance, though plugins may
  eventually allow other types to be used.
* [$view] this is the "root" view, which contains a tree who's
  leaves are the visible Edit views.
* [$ext] a plain table that extensions can set Edit-local values
  too. Very useful for plugins.
* [$:buffer(idOrPath) --> Buffer] this will get or create a buffer.
* [$:focus(idOrPath) --> Edit] focus on a buffer, replacing
  the current one.
]

Most plugins will simply get [$edit] and then insert/remove/search
its [$buf] data using its APIs and/or change its [$l,c] (line,column) values.
They are free to use any lua API to do so, but should avoid large amounts
of work as much as possible.

